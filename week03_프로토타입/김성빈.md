# 프로토타입

## 프로토타입이 관여하는 문법

1. 프로퍼티 읽기 - 객체의 프로퍼티 접근 시 프로토타입 체인에서 검색함. '쓰기'는 해당 객체에서만 수행됨.
2. 상속 - 프로토타입으로만 상속이 가능함. 상속은 자식 객체의 `__proto__`를 지정해 자식 객체에서 부모 객체(주로 생성자의 `prototype` 프로퍼티)의 프로퍼티를 접근할 수 있는 것임.
3. 객체 - 모든 객체는 Prototype(`__proto__`)를 가지며 `Object.prototype`이 기본 `__proto__`임.
4. 생성자 함수 - 생성자 함수의 `prototype` 프로퍼티로 등록된 객체가 공유되는 프로토타입이 됨.
5. `__proto__`는 접근자 프로퍼티로, 단방향을 강제하기 위한 Validation을 수행함.
6. `key in obj` 문법은 대상 객체의 프로퍼티 체인을 탐색함.
7. `for-in` 반복문은 객체의 프로퍼티 체인 상의 모든 key를 순회함. `enumerable=false` 혹은 key 타입이 `Symbol`인 경우 순회 대상에서 제외됨.

## 주의사항

1. 생성자가 아니면 `prototype` 프로퍼티가 없음. 화살표 함수와 ES6 메소드가 여기 해당함.
2. 리터럴로 선언한 객체, 함수 역시 `Object`, `Function`을 각각 `prototype.constructor`로 소유함.
3. 생성자의 `prototype` 프로퍼티는 객체이므로 `생성자.prototype.__proto__ === Object.prototype`이다.
4. 프로토타입 체인의 최상위는 언제나 `Object.prototype`이다.
5. `섀도잉`이란 프로퍼티가 가려지는 현상을 의미한다.
6. 프로토타입은 교체할 수 있다.
7. 생성자 함수의 `prototype` 프로퍼티에 새 객체를 할당할 경우 `constructor` 프로퍼티를 정의해줘야 한다. 만약 이를 하지 않는다면 `constructor`에 접근할 수 없다.
8. `instanceof`는 생성자 함수의 `prototype` 객체가 프로토타입 체인 상에 존재하는지 여부를 반환한다. 이 때 `prototype` 객체에 `constructor`가 없어도 같은 객체이면 `true`를 반환한다.
9. 객체 리터럴에서 `__proto__`를 직접 할ㄷㅇ하면 '직접 상속'이 가능하다.
10. 정적 메소드는 생성자 함수의 프로퍼티인데, 각 인스턴스에서도 `인스턴스.constructor.정적메소드()`로 호출할 수 있다.
