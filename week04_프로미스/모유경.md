# 프로미스

`#비동기`

### 목차

- [콜백패턴의 보완](#✏️-콜백패턴의-보완)
  - [콜백 헬](#🔎-콜백-헬)
  - [에러처리의 문제](#🔎-에러처리의-문제)
- [후속처리 메서드](#✏️-후속처리-메서드)
  - [프로미스의 에러처리](#🔎-프로미스의-에러처리)
- [프로미스 체이닝](#✏️-프로미스-체이닝)
- [참고 문헌](#참고-문헌)

<div style="height:100px"></div>

## ✏️ 콜백패턴의 보완

콜백 패턴의 단점

- 콜백 헬로 인한 나쁜 가독성
- 비동기 처리 중 발생한 에러의 처리가 곤란
- 여러개의 비동기 처리를 한번에 처리하는데 한계를 갖음

프로미스의 사용으로 위 단점을 보완하면서, 비동기 처리시점을 명확하게 표현할 수 있다는 장점을갖음

### 🔎 콜백 헬

함수 내붕 비동기로 동작하는 코드를 포함한 함수를 비동기 함수라고 한다. 비동기 함수를 호출하면 함수 내부의 비동기로 동작하는 코드가 완료되지않았다고 해도 기다리지 않고 종료된다. 이는 비동기 함수가 종료된 이후에 코드가 완료된다는 것을 의미하므로, 처리 결과에 대한 반환을 기대한 대로 동작하지않음을 말한다.

따라서 비동기 처리 결과에 대한 후속처리를 위해서는 비동기 함수가 비동기 처리결과를 갖고 또 다시 비동기함수를 호출해야하므로 함수호출이 중첩적으로 발생하며 복합해지는데 이를 콜백 핼이라고 함

### 🔎 에러처리의 문제

비동기 함수는 콜백 함수가 호출되는 것을 기다리지않고 즉시 종료되므로 콜스택에서 제거된다. 예를 들어 `setTimeout`함수의 콜백함수가 실행된다고 해도, 이미 `setTimeout`함수는 콜스택에서 제거된 상태이므로 해당 함수를 호출한 것이 `setTimeout`함수가 아니게 된다.

`setTimeout`함수가 `setTimeout`함수의 콜백함수의 호출자라면 콜스택의 현재 실행중인 실행컨텍스트가 콜백 함수의 실행 컨텍스트일때 현재 실행중인 실행 컨텍스트의 하위 실행 컨텍스트가 `setTimeout`함수여야한다.

에러는 호출자 방향으로 전파된다. 하지만 `setTimeout`함수의 호출함수를 호출한 것은 `setTimeout`함수가 아니므로, `setTimeout`함수의 콜백함수가 발생시킨 에러는 catch블록에서 캐치되지 않는다.

<div style="height:100px"></div>

## ✏️ 후속처리 메서드

`Promise.prototype.then`메서드

- 두개의 콜백함수를 인수로 전달받으며, 첫번째 콜백함수는 fullfilled상태일때 호출되는 성공 처리 콜백함수이며, 두번째 콜백함수는 rejected상태일때 호출되는 실패 처리 콜백함수이다

`Promise.prototype.catch`메서드

- rejected상태일때 호출되는 한개의 콜백함수를 인수로 전달받는다.

- `Promise.prototype.finally`메서드

- 한개의 콜백함수를 인수로 전달받아, fullfilled | rejected와 상관없이 무조건 한 번 호출되므로 프로미스의 상태와 상관없이 공통적으로 수행해야할 처리 내용이 있을 때 유용하다.

### 🔎 프로미스의 에러처리

비동기 처리 결과에 대한 후속처리는 프로미스가 제공하는 후속 처리 메서드 then, catch 사용해서 수행할 수 있다.

then메서드의 두번째 콜백 함수는 첫 번재 콜백함수에서 발생한 에러를 캐치하지 못하고 코드가 복잡해지므로 가독성이 좋지않다. catch메서드를 모든 then메서드를 호출한 이후에 호출하면 비동기 처리에서 발생한 에러뿐만 아니라, then 메서드 내부에서 발생한 에러까지 모두 캐치할 수 있으며 가독성을 보장하므로 catch메서드의 사용을 권장한다.

<div style="height:100px"></div>

## ✏️ 프로미스 체이닝

후속처리메서드는 **언제나 프로미스를 반환하**므로 연속적으로 호출할 수 있으며, 이를 프로미스 체이닝 promise chaining이라고 한다.

후속 처리 메서드는 항상 콜백함수가 반환한 프로미스를 반환하며, 만약 후속처리 메서드의 콜백함수가 프로미스가 아닌 값을 반환하더라도 그 값을 암묵적으로 resole | reject하여 프로미스를 생성해 반환한다.

따라서 프로미스는 프로미스 체이닝을 통해 비동기 처리 결과를 전달받아 후속처리를 하기때문에 콜백패턴을 사용하므로 콜백 함수를 사용하는 것은 동일하나, 비동기 처리를 위한 콜백 패턴에서 발생하는 콜백 헬이 발생하지않는다.

콜백 패턴은 가독성이 좋지 않다는 단점을 갖는데 이는 ES8에서 도입된 async/await을 통해 프로미스의 후속처리메서드없이 동기 처리 처럼 프로미스가 처리 결과를 반환하고록 구현할 수 있다.

<div style="height:150px"></div>

### 📖 참고 문헌

- [도서] 모던자바스크립트 45
