클로저에 대해 이해하려면 **실행 컨텍스트**에 대해 알아야한다.

## **실행 컨텍스트**

\- 자바스크립트의 동작원리를 담고있는 핵심 개념

\- 소스 코드를 실행하는 데 필요한 환경을 제공하고 코드 실행결과를 실제로 관리하는 영역

\- 식별자(변수, 함수, 클래스 등의 이름)를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 매커니즘으로, 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다.

### **소스 코드의 타입**

- 전역코드 : 전역에 존재하는 소스코드
- 함수코드 : 함수 내부에 존재하는 소스코드
- eval코드 : 빌트인 전역 함수인 eval 함수에 인수로 전달되어 실행되는 소스코드
- 모듈코드 : 모듈 내부에 존재하는 소스코드

각각 코드들은 **코드 평가 후 실행 컨텍스트**가 된다.

![image](https://github.com/prgrms-web-devcourse/FEDC5_JavaScript_study/assets/90139306/547af081-fbf8-4971-9153-8d3ecfde0cbf)

\- 평가 과정에서는 실행컨텍스트를 생성하고 변수, 함수 등의 선언문만 먼저 실행하여 생성된 변수나 함수 식별자를 키로 실행 컨텍스트가 관리하는 스코프(렉시컬 환경의 환경 레코드)에 등록한다.

**\[참고\]**

eval 함수 : **문자로 표현 된 JavaScript 코드를 실행하는 함수**, 사용을 지양해야하는 함수

```
eval(string)
```

```
console.log(eval('2 + 2'));
// expected output: 4

console.log(eval(new String('2 + 2')));
// expected output: 2 + 2

console.log(eval('2 + 2') === eval('4'));
// expected output: true

console.log(eval('2 + 2') === eval(new String('2 + 2')));
// expected output: false
```

렉시컬 환경 : **특정 코드가 작성, 선언된 환경(장소)을 의미한다.**

### **실행컨텍스트의 역할**

**전역코드 평가 -> 전역코드 실행 -> 함수코드 평가 -> 함수 코드 실행**

전역코드가 순차적으로 실행되다가 **함수가 호출되면 일시 중단하고 코드 실행 순서를 변경하여 함수 내부로 진입**한다.

또한 함수 호출이 종료되면 함수 호출 이전으로 되돌아가기 위해 현재 실행 중인 코드와 이전에 실행하던 코드를 구분하여 관리해야 한다.  이처럼 코드가 실행되려면 **스코프, 식별자, 코드 실행 순서 등의 관리가 필요**하다.

이를 관리하는 것이 바로 **실행 컨텍스트**다.

**실행 컨텍스트는** 소스 코드를 실행하는 데 필요한 환경을 제공하고 코드 실행결과를 실제로 관리하는 영역이다.

**실행컨텍스트는** 식별자(변수, 함수, 클래스 등의 이름)를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 매커니즘으로, 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다.

**식별자와 스코프**는 실행 컨텍스트의 **렉시컬 환경**으로 관리

**코드 실행 순서**는 **실행 컨텍스트 스택**으로 관리

### **실행컨텍스트 스택**

![image](https://github.com/prgrms-web-devcourse/FEDC5_JavaScript_study/assets/90139306/a0441de7-d2b8-4778-8749-736198e3aa65)

\- 실행 컨텍스트 스택의 최상위에 존재하는 실행 컨텍스트는 언제나 **현재 실행 중인 실행컨텍스트**

\- 이를 **실행 컨텍스트**라고 한다.

### **렉시컬 환경**

![image](https://github.com/prgrms-web-devcourse/FEDC5_JavaScript_study/assets/90139306/b93f1a8b-9bb7-4e2d-bf1d-01bd99f1c841)

**\- 식별자와 식별자에 바인딩된 값, 그리고 상위 스코프에 대한 참조를 기록하는 자료구조로 실행 컨텍스트를 구성하는 컴포넌트**

**\- 스코프를 구분하여 식별자를 등록하고 관리하는 저장소 역할을 하는 렉시컬 스코프의 실체**

![image](https://github.com/prgrms-web-devcourse/FEDC5_JavaScript_study/assets/90139306/6805a070-0ca3-4ab4-8249-8bebc335edf6)

**\- 환경 레코드 : 스코프에 포함된 식별자를 등록하고 등록된 식별자에 바인딩된 값을 관리하는 저장소**

**\- 외부 렉시컬 환경에 대한 참조 : 상위 스코프를  가리킨다.**

\[참고\]

스코프 체인 :

**실행 컨텍스트는 렉시컬 환경 컴포넌트와 변수 환경 컴포넌트로 구성된다.**

![image](https://github.com/prgrms-web-devcourse/FEDC5_JavaScript_study/assets/90139306/d1c97485-bff9-489f-b91c-7fc7a8b8c5cd)

\- 생성 초기에 렉시컬 환경 컴포넌트와 변수 환경 컴포넌트는 하나의 동일한 렉시컬 환경을 참조한다.

\- 이후 몇 가지 상황을 만나면 변수 환경 컴포넌트를 위한 새로운 렉시컬 환경을 생성하고, 이때부터 변수환경 컴포넌트와 렉시컬 환경 컴포넌트는 내용이 달라지는 경우도 있다.

## **실행컨텍스트 생성과 식별자 검색 과정**

### **1\. 전역 실행 컨텍스트 생성**

전역 실행 컨텍스트를 생성하여 실행 컨텍스트 스택에 푸시한다.

![image](https://github.com/prgrms-web-devcourse/FEDC5_JavaScript_study/assets/90139306/e3874f87-92d0-431b-bfba-7be850a6c1dc)

### **2\. 전역 렉시컬 환경 생성**

전역 렉시컬 환경을 생성하고 전역 실행 컨텍스트에 바인딩한다.

렉시컬 환경은 **환경 레코드**와 **외부 렉시컬 환경에 대한 참조**로 구성된다.

![image](https://github.com/prgrms-web-devcourse/FEDC5_JavaScript_study/assets/90139306/baaeefc5-7ea0-454c-bfa7-8080539222d0)

#### **2-1. 전역 환경 레코드 생성**

\- 전역 변수를 관리하는 전역 스코프, 전역 객체의 빌트인 전역 프로퍼티와 빌트인 전역함수, 표준 빌트인 객체를 제공

\- 전역 환경 레코드는 객체 환경 레코드와 선언적 환경 레코드로 구성되어 있다.

**2-1-1. 객체 환경 레코드 생성**

\- 전역 코드 평가 과정에**서 var 키워드로 선언한 전역 변수**와 **함수 선언문으로 정의된 전역함수**는 전역 환경 레코드의 객체 환경 레코드에 연결된 BindingObject를 통해 전역객체의 **프로퍼티**와 **메서드**가 된다.

![image](https://github.com/prgrms-web-devcourse/FEDC5_JavaScript_study/assets/90139306/e8eb008e-05ce-43c3-b30e-e1eef56248fe)

**2-1-2 선언적 환경 레코드 생성**

\- var 키워드로 선언한 전역 변수와 함수 선언문으로 정의한 전역 함수 이외의 선언, 즉 let, const 키워드로 선언한 전역변수는 선언적 환경 레코드에 등록되고 관리된다.

![image](https://github.com/prgrms-web-devcourse/FEDC5_JavaScript_study/assets/90139306/c14f5837-92c0-417e-87b3-afe0371f1196)

### **2.2. this 바인딩**

\- 전역 환경 레코드의 \[\[GlobalThisValue\]\] 네부  슬롯에 this가 바인딩된다.

\- 일반적으로 this는 전역 객체를 가리키므로 전역 환경 레코드의 \[\[GlobalThisValue\]\] 내부 슬롯에는 전역 객체가 바인딩된다.

\- 전역 코드에서 this를 참조하면 전역 환경 레코드의 내부 슬롯에 바인딩되어있는 객체를 반환한다.

![image](https://github.com/prgrms-web-devcourse/FEDC5_JavaScript_study/assets/90139306/4d2c3353-d12a-4abb-9055-0f8928a42625)

### **2.3 외부 렉시컬 환경에 대한 참조 결정**

\- 현재 평가 중인 소스코드를 포함하는 외부 소스코드의 렉시컬 환경, 즉 상위 스코프를 가진다. 이를 통해 단방향 링크드 리스트인 스코프 체인을 구현한다.

![image](https://github.com/prgrms-web-devcourse/FEDC5_JavaScript_study/assets/90139306/9686b894-a642-41e2-8353-9da0b9f6f46d)

\- 현재 평가 중인 소스코드는 전역 코드다.

\- 전역코드를 포함하는 소스코드는 없으므로 전역 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 null이 할당된다.

\- 이는 전역 렉시컬 환경이 스코프 체인의 종점에 존재함을 의미한다.

## **3\. 전역코드 실행**

\- 전역코드가 순차적으로 실행되기 시작한다.

\- 전역 변수 x, y에 값이 할당된다.

\- 함수 foo가 호출된다.

![image](https://github.com/prgrms-web-devcourse/FEDC5_JavaScript_study/assets/90139306/6dad7b0e-7008-4a80-91f0-ac32726576ba)

## **4\. foo 함수 코드 평가**

**\- 아래 순서를 진행한다.**

**1\. 함수 실행 컨텍스트 생성**

**2\. 함수 렉시컬 환경 생성**

**2.1 함수 환경 레코드 생성**

**2.2 this 바인딩**

**2.3 외부 렉시컬 환경에 대한 참조 경정**

![image](https://github.com/prgrms-web-devcourse/FEDC5_JavaScript_study/assets/90139306/08593402-b2ff-43f4-811e-249b60c05948)

## **5\. foo 함수 실행**

\- foo함수의 소스코드가 순차적으로 실행

\- 매개변수에 인수가 할당되고, 변수 할당문이 실행되어 지역 변수 x, y에 값이 할당됨

![image](https://github.com/prgrms-web-devcourse/FEDC5_JavaScript_study/assets/90139306/13fd04ee-5d81-4e87-9a59-a17dffa20bd2)

---

## **클로저**

\- 함수를 일급 객체로 취급하는 함수형 프로그래밍 언어에서 사용되는 중요한 특성

\- 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.

### **렉시컬 스코프** 

"외부 렉시컬 환경에 대한 참조"에 저장할 참조 값, 즉 상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 환경에 의해 결정된다.

### **함수 객체의 내부 슬롯\[\[Environment\]\]**

\- 렉시컬 스코프가 가능하려면 함수는 자신이 호출되는 환경과는 상관없이 자신이 정의된 환경, 즉 상위 스코프를 기억해야한다. 이를 위해 함수는 자신의 **내부 슬롯 \[\[Environment\]\]에** 자신이 정의된 환경, 즉 **상위 스코프의 참조를 저장**한다.

[##_Image|kage@nxMIO/btsv7opX3Au/MtGbQNLBSERXUmV3iwdXR0/img.png|CDM|1.3|{"originWidth":856,"originHeight":537,"style":"alignCenter"}_##]

## **클로저와 렉시컬 환경**

```
const x = 1;

function outer(){
	const x = 10;
    const inner = function (){ console.log(x);};
    return inner;
}

// outer 함수를 호출하면 중첩 함수 inner를 반환한다.
// 그리고 outer 함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 pop되어 제거된다.
ocnst innerFunc = outer();
innerFunc(); // 10
```

\- outer 함수가 종료되어 실행 컨텍스트에서 제거되었으므로 지역 변수 x 또한 생명주기를 마감한다. 하지만 위 innerFunc()의 실행 결과는 지역 변수의 값인 10 출력된다. x가 부활이라도 한 듯이 동작한다.

\- 이처럼 **외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가 종료한 외부함수의 변수를 참조할 수 있다. 이러한 중첩 함수를 클로저라고 부른다.**

![image](https://github.com/prgrms-web-devcourse/FEDC5_JavaScript_study/assets/90139306/bb64c879-0089-4bb3-8be1-55014d0b833e)

---

![image](https://github.com/prgrms-web-devcourse/FEDC5_JavaScript_study/assets/90139306/c32256d7-5a02-43e3-89ca-9467467ad5ab)

\- outer 함수의 실행이 종료되면 inner 함수를 반환하면서 outer 함수의 생명 주기가 종료된다.

\- **이때 outer 함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 제거되지만 outer 함수의 렉시컬 환경까지 소멸하는 것은 아니다.**

\- **outer 함수의 렉시컬 환경은 **in**ner 함수의 \[\[Environment\]\] 내부 슬롯에 의해 참조**되고 있고, **inner 함수는 전역 변수 innerFunc에 의해 참조**되고 있으므로 **가비지 컬렉션의 대상이 되지 않기 때문이다.**

---

![image](https://github.com/prgrms-web-devcourse/FEDC5_JavaScript_study/assets/90139306/cd0407c3-f7bf-4f6c-baa3-497a3136891c)

\- outer 함수가 반환한 inner 함수를 호출하면 inner 함수의 실행 컨텍스트가 생성되고, 실행컨텍스트 스택에 푸시된다.

\- **렉시컬 환경 외부 렉시컬 환경에 대한 참조**에는 **inner 함수 객체의 \[\[Environment\]\] 내부 슬롯에 저장되어 있는 참조값**이 할당된다.

> 이 때 상위 스코프의 어떤 식별자도 참조하지 않는 함수는 클로저가 아니다

### **클로저를 사용하는 이유**

\- 상태가 의도치 않게 변견되지 않도록 안전하게 은닉하고 특정함수에게만 상태 변경을 허용하여 상태를 안전하게 변경하고 유지하기 위해 사용한다.

### **캡슐화와 정보은닉**

\- 자바스크립트는 public, private, protected 같은 접근 제한자를 제공하지 않는다. 모든 프로퍼티와 메서드는 기본적으로 public하다.

\- 함수 생성자와 프로토타입 메서드를 통해 정보은닉이 부분적으로 가능하지만 온전하게 지원하지 않는다.

\- 2021년 1월 당시에는 TC39 프로세스의 stage 3(candidate)에는 클래스에 private필드를 정의할 수 있는 새로운 표준 사양이 제안되어 있다.

### **클로저 사용시 자주 발생하는 실수**

**\- var키워드 사용 시 블록 레벨 스코프가 아닌 함수 레벨 스코프를 가지는 경우**

**\-> let을 사용하면 해결됨 -> let은 블록 레벨 스코프를 가지기 때문에**

**\-> 함수형 프로그래밍 기법인 고차 함수를 사용하는 방법**
