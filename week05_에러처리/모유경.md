# 에러처리

`#에러처리`

<div style="height:100px"></div>

## ✏️ 에러처리의 필요성

- 에러처리에 대응하지 않는다면, 프로그램은 발생한 에러에 대해서 대처하지않고 강제 종료될 것임.
  - `try ...catch`문을 통해서 에러가 발생해도 계속해서 코드를 실행할 수 있음
- 직접적으로 에러를 발생하지는 않는 예외적인 상황에 대해서도 대응이 필요한데, 대표적으로 DOM요소를 찾지 못하고 null을 반환하는 경우임
  - if문을 통한 반환값의 확인
  - 옵셔널 체이닝 연산자 `?.`의 사용

### 🔎 try ...catch

```js
try {
  //실행할 코드(에러 발생 가능성이 존재하는 코드)
} catch (err) {
  //try코드 블록에서 에러가 발생하는 경우 해당 코드 블록이 실행
  //err에는 try코드블록에서 발생한 error객체가 전달
} finally {
  //에러 발생과 상관없이 반드시 한번은 실행
}
```

- finally는 불필요하다면 생략 가능
- catch도 생략가능하나, catch문이 없는 try는 의미가 없으므로 생략하지않음

<div style="height:100px"></div>

## ✏️ Error

### 🔎 Error 객체

- Error생성자 함수가 생성한 에러객체는 message 프로퍼티와 stack프로퍼티를 갖음
  - message 프로퍼티: Error생성자 함수에 인수로 전달한 에러메시지
  - stack 프로퍼티: 에러를 발생시킨 콜스택의 호출정보를 나타내는 문자열로 디버깅 목적으로 사용
- 생성자 함수를 통해 생성한 에러 객체의 프로토타입을 모두 Error.prototype을 상속받음

### 🔎 throw 문

- Error생성자 함수로 에러 객체를 생성해도 에러가 발생하는 것을 아님
- 에러 발생을 위해서는 try코드블록에서 throw문을 통해 에러 객체를 던져야함 `throw 표현식;`

```js
try {
  //에러객체를 던지면 catch코드블록이 실행
  throw new Error("wrong");
} catch (err) {
  console.log(err);
}
```

### 🔎 에러 전파

- 에러는 호출자 방향으로 전파 됨(콜 스택 아래 방향으로 전파)
- throw된 에러를 캐치해 적절히 대응하면 프로그램이 호출자 방향으로 전파하는 것을 막아 강제종료시키지않고 코드의 실행 흐름을 복구할 수 있음.
  - 어디서도 throw된 에러를 캐치하지않으면 프로그램은 강제종료됨
