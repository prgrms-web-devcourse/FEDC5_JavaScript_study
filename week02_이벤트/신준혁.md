**이벤트 핸들러** : 이벤트가 발생했을 때 호출될 함수, 이벤트가 발생했을 때 브라우저에 호출을 위임한 함수

**이벤트 핸들러 등록** : 브라우저에게 이벤트 핸들러의 호출을 위임하는 것

**이벤트 드리븐 프로그래밍** : 프로그램의 흐름을 이벤트 중심으로 제어하는 프로그래밍 방식

## **이벤트 핸들러 등록**

#### **1\. 이벤트 핸들러 어트리 뷰트 방식**

\- on 접두사와 이벤트의 종류를 나타내는 이벤트 타입으로 이루어짐

\- 어트리뷰트 값으로 **함수 참조가 아닌 함수 호출문** 등의 문을 할당

\- 함수가 아닌 값을 반환하는 호출문을 이벤트 핸들러로 등록하면 브라우저가 이벤트 핸들러를 호출할 수 없음

```
<button onclick = "sayHi("Lee")">Click me</button>
```

#### **2\. 이벤트 핸들러 프로퍼티 방식**

\- window객체, Document, HTMLElement 타입의 DOM 노드 객체는 이벤트에 대응하는 이벤트 핸들러 프로퍼티를 가지고 있음

\- 이벤트 타깃, 이벤트 타입, 이벤트 핸들러로 구성

**\- 이벤트 핸들러 프로퍼티에는 하나의 이벤트 핸들러만 바인딩 할 수 있다.(먼저 등록된 이벤트 핸들러만 실행됨)**

```
$button.onclick = function () {
 	console.log("button click");
 };
```

### **3\. addEventListener 메서드 방식**

\- EventTarget.prototype.addEventListener 메서드를 사용해 이벤트 핸들러 등록 가능

\- 마지막 매개변수에는 이벤트를 캐치할 이벤트 전파 단계를 지정한다.

**\- 이때 이벤트 핸들러 프로퍼티와 addEventListener 을 동시에 사용하면 2개의 이벤트 핸들러가 모두 호출된다. (등록된순서대로)**

**\- 단, addEventLisner 방식이 동일한 요소에 중복되어 사용되면 하나의 이벤트 핸들러만 등록된다.**

```
EventTarget.addEventListener("eventType",functionName[,useCapture]);
```

## **이벤트 핸들러 제거**

\- removeEventListener 메서드에 전달할 인수는 addEventListener 메서드와 동일하다. 전달할 인수가 일치해야 이벤트 핸들러가 제거 된다.

```
EventTarget.addEventListener("click",functionName);
```

## **이벤트 객체**

\- 클릭이벤트에 의해 생성된 이벤트 객체는 이벤트 핸들러의 첫번째 인수로 전달되어 매개변수 e에 암묵적으로 할당된다.

**\-> 이는 브라우저가 이벤트 핸들러를 호출할 때 이벤트 객체를 인수로 전달하기 때문이다.**

![image](https://github.com/prgrms-web-devcourse/FEDC5_JavaScript_study/assets/90139306/d4aeb59b-70b8-43fe-9d9d-bdaf63488310)
\-반드시 첫 번째 매개변수 이름이 event이어야한다. 다른 이름이면 이벤트 객체를 전달받지 못한다.

> e 나 ev는 불가능 한가?

#### **이벤트 객체의 상속 구조**

\- Event, UIEvent, MouseEvent 등 모두 생성자 함수, 따라서 생성자 함수를 호출하여 이벤트 객체를 생성 가능하다.

#### **마우스 정보 취득**

#### 1\. clientX, clientY

위 메서드는 클라이언트 영역 내의 가로,세로 좌표를 제공한다.. 여기서 클라이언트 영역은 현재 보이는 브라우저 화면이 기준이 된다.

**clientX** : 브라우저 페이지에서의 X좌표 위치를 반환하나 스크롤은 무시하고 해당 페이지의 상단을 0으로 측정한다

**clientY** : 브라우저 페이지에서의 Y좌표 위치를 반환하나 스크롤은 무시하고 해당 페이지의 상단을 0으로 측정 한다 .

#### 2\. offsetX, offsetY

위 메서드는 이벤트 대상이 기준이 된다.. ( 화면 중간에 있는 박스 내부에서 클릭한 위치를 찾을 때 해당 박스의 왼쪽 모서리 좌표가 0이 된다. 화면의 기준이 된다.)

전체 문서를 기준으로 합니다(스크롤 화면 포함)

**offsetX** : 이벤트 대상 객체에서의 상대적 마우스 x좌표 위치를 반환한다

**offsetY** : 이벤트 대상 객체에서의 상대적 마우스 y좌표 위치를 반환한다

#### 3\. pageX, pageY

위 메서드는 전체 문서를 기준으로 x,y 좌표를 반환한다 . 스크롤 화면을 포함해서 측정한다 .

**pageX** : 브라우저 페이지에서의 x좌표 위치를 반환한다

**pageY** : 브라우저 페이지에서의 Y좌표 위치를 반환한다

#### 4\. screenX, screenY

위 메서드는 모니터 화면을 기준으로 좌표를 제공한다. 여기서 중요한 점은 브라우저 화면이 아니라 자신의 모니터 화면 전체를 기준으로 좌표를 측정한다는 점이다.

**screenX** : 전체 모니터 스크린에서의 x좌표 위치를 반환한다.

**screenY** :전체 모니터 스크린에서의 y좌표 위치를 반환한다.

## **이벤트 전파**

\- DOM 트리 상에 존재하는 DOM 요소 노드에서 발생한 이벤트는 DOM 트리를 통해 전파된다. 이를 이벤트 전파라고한다.

![image](https://github.com/prgrms-web-devcourse/FEDC5_JavaScript_study/assets/90139306/d13502c8-cc71-42f5-beb7-5fc693162120)

1\. 캡처링 단계 : 이벤트가 상위요소에서 하위 요소 방향으로 전파

2\. 타깃 단계 : 이벤트가 이벤트 타깃에 도달

3\. 버블링 단계 : 이벤트가 하위요소에서 상위 요소 방향으로 전파

```
<ul>
    <li id = "apple">Apple</li>
    <li id = "banana">banana</li>
    <li id = "orange">orange</li>
</ul>
```

#### **발생 과정(ul 요소에 이벤트 핸들러를 바인딩하고, ul의 하위 요소인 li를 클릭했을 때)**

1\. li 클릭 후 클릭 이벤트 발생 -> **이벤트 타깃**이 된다. **ul은 currentTarget이 된다**.

2\. 클릭 이벤트 객체는 window에서 시작해서 **이벤트 타깃** 방향으로 전파된다. -> **캡처링 단계**

3\. 이벤트 객체는 이벤트를 발생시킨 이벤트 타깃에 도달 -> **타깃 단계**

4\. 이벤트 객체는 이벤트 타깃에서 시작해서 window 방향으로 전파된다 -> **버블링 단계**

**currentTarget : 이벤트 핸들러가 적용된 객체 요소**

**target : 클릭한 요소**

**이벤트 핸들러 어트리뷰트/ 프로퍼티 방식**으로 등록한 이벤트 핸들러는 타깃 단계와 버블링 단계의 이벤트만 캐치할 수있다.

**addEventListener 메서드 방식**으로 등록한 이벤트 핸들러는 타깃 단계와 버블링 단계 뿐만 아니라 캡처링 단계의 이벤트도 선별적으로 캐치할 수 있다. -> **3번쨰 인수를 true로 하면 가능**

**이를 통해 이벤트는 이벤트를 발생시킨 이벤트 타깃은 물론 상위 DOM 요소에서도 캐치할 수 있다.**

```
<body>
	<p>버블링과 캡처링 이벤트<button>버튼</button></p>
</body>
```

이벤트는 **캡처링 - 타깃 - 버블링 단계로 전파**되므로

만약 button 요소에서 클릭 이벤트가 발생하면

먼저 **캡처링 단계를 캐치하는 p요소**의 이벤트가 호출되고,

그 후 **버블링 단계의 이벤트를 캐치하는 body요소**의 이벤트 핸들러가 순차적으로 호출된다.

#### **p태그의 이벤트 핸들러 -> button의 이벤트 핸들러 -> body태그의 이벤트 핸들러**

## **이벤트 위임**

\- 상위요소 ul, 하위요소 li가 있는 상태에서 모든 li에 이벤트 핸들러를 등록하려고 할 때 li 요소가 100개면 100개의 이벤트 핸들러를 등록해야한다.

\- 이 경우 많은 DOM 요소에 이벤트 핸들러를 등록하므로 성능 저하의 원이이 될 뿐더러 유지보수에도 부적합한 코드를 생산하게 된다.

**이벤트 위임**은

**여러개의 하위 DOM 요소에 각각 이벤트 핸들러를 등혹하는 대신 하나의 상위 DOM 요소에 이벤트 핸들러를 등록하는 방법이다.**

"이벤트 전파" 에서 보았듯이 이벤트는 이벤트 타깃은 물론 상위 DOM 요소에서도 캐치할 수 있다.

\[참고\] matches 메서드는 **인수로 전달된 선택자에 의해 특정 노드를 탐색가능한지 확인**한다.

```
function activate({target}) {
	//이벤트를 발생시킨 요소(target)가 ul#fruits의 자식요소가 아니라면 무시한다.
	if(!target.matches("$fruit > li")) return;

    ...
```

## **DOM 요소의 기본 동작 조작**

```
e.preventDefault();
```

\- DOM요소의 기본 동작을 중단 시킨다.

#### **이벤트 전파 방지**

```
e.stopPropagation();
```

\- 이 메서드를 사용하면 상위요소에서 이벤트를 캐치할 수 없게한다.

\- 자체적으로 이벤트를 처리할 수 있다. -> 자신에게 바인딩된 이벤트 핸들러만 실행되도록한다.

## **이벤트 핸들러 내부의 this**

\- 일반 함수로서 호출되는 함수 내부의 this는 전역 객체인 window를 가리킨다.

\- 단, 이벤트 핸들러를 호출할 때 인수로 전달한 this는 이벤트를 바인딩한 DOM요소를 가리킨다.

이벤트 핸들러 프로퍼티 방식과 addEventListener 메서드 방식 모두 이벤트 핸들러 내부의 this는 이벤트를 바인딩한 DOM 요소를 가리킨다.

**즉, 이벤트 핸들러 내부의 this는 이벤트 객체의 currentTarget 프로퍼티와 같다.**

이벤트 핸들러에 인수전달

\- 이벤트 어트리뷰트 방식은 함수 호출문을 사용할 수 있기 때문에 인수를 전달할 수 있다.

\- 하지만 이벤트 핸들러 프로퍼티 방식과 addEventListner메서드 방식은 핸들러를 브라우저가 호출하기 때문에 함수 호출문이 아닌 함수 자체를 등록해야한다. 즉 인수를 전달할 수 없다.

-> 하지만 두가지 방법이 있다.

**1\. 이벤트 핸들러 내부에서 함수를 호출하면서 인수를 전달할 수 있다.**

```
const check = 인수 => {
	$msg.textContent = 인수
}

//이벤트 핸들러 내부에서 함수를 호출하면서 인수를 전달한다.
$input.onblur=() =>{
	check(인수);
}
```

**2\. 이벤트 핸들러를 반환하는 함수를 호출하면서 인수를 전달할  수 있다.**

```
//이벤트 핸들러를 반환하는 함수
const check = 인수 => e =>{
	$msg.textContent = 인수
};

//이벤트 핸들러를 반환하는 함수를 호출하면서 인수를 전달한다.
$input.onblur = check(인수);
```

## **커스텀 이벤트**

\- 이벤트 객체는 Event, UIEvent, MoustEvent 같은 이벤트 생성자 함수로 생성할 수 있다.

\- 이벤트가 발생하면 암묵적으로 생성되는 이벤트 객체는 발생한 이벤트의 종류에 따라 이벤트 타입이 결정된다.

\-> 하지만 이벤트 객체는 임의의 이벤트 타입을 지정할 수 있다. 이를 커스텀 이벤트라고 한다.

```
//KeyboardEvent 생성자 함수로 keyup 이벤트 타입의 커스텀 이벤트 객체를 생성
const keyboardEvent = new KeyboardEvent("keyup");
```

\- 생성된 이벤트 객체는 버블링되지 않으며 preventDefault 메서드로 취소할 수도 없다.

#### **커스텀 이벤트 디스패치**

\- 생성된 커스텀 이벤트는 dispatchEvent 메서드로 디스패치(이벤트를 발생시키는 행위)할 수 있다.

**\- 일반적으로 이벤트 핸들러는 비동기 처리 방식으로 동작하지만 dispatchEvent 메서드는 이벤트 핸드러를 동기 처리 방식으로 호출한다.**

```
const $button = document.querySelector(".btn");

//버튼요소 click 커스텀 이벤트 핸들러를 등록
//커스텀 이벤트를 디스패치하기 이전에 이벤트 핸들러를 등록해야한다.
$button.addEventListener("click", e=>{ ... }_;

//커스텀 이벤트 생성
const customEvent = new MouseEvent("click");

//커스텀 이벤트 디스패치(동기처리), click 이벤트 발생
$button.dispatchEvent(customEvent);
```
